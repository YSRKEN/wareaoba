/* 戦場のカメラマン 青葉 Ver.1.1 */

	#packopt name "wareaoba"
	#include "hspcv.as"
	#include "hspext.as"
	onexit gosub *exit

/* マクロ宣言 */
	#define kSoftName "戦場のカメラマン 青葉"
	#define ctype POS_X(%1) (%1) * kObjSpaceX + kObjSpace
	#define ctype POS_Y(%1) (%1) * kObjSpaceY + kObjSpace
	#define POS_XY(%1, %2) pos POS_X(%1), POS_Y(%2)
	#define ctype SIZE_X(%1) (%1) * kObjSpaceX - kObjSpace
	#define ctype SIZE_Y(%1) (%1) * kObjSpaceY - kObjSpace

/* 定数宣言 */
	// 画面ID
	#enum kMainWindowID = 0	;メイン画面のID
	#enum kSelectWindowID	;選択画面のID
	#enum kDesktopBufferID	;デスクトップのスクショを保存するためのID
	#enum kFlashBufferID	;艦これの画面を保存するためのID
	#enum kCheckBufferID	;ズレ検出用のID
	#enum kRingBufferID		;リングバッファの最初のID
	// CV画面ID
	#enum global kCVDesktopBufferID = 0
	#enum global kCVFlashBufferID
	// オブジェクト
	#const global kFlashWX 800
	#const global kFlashWY 480
	#const kObjX 60			;ボタン等のオブジェクトの大きさ
	#const kObjY 20
	#const kObjSpace 10		;オブジェクトの間隔
	#const kObjSpaceX kObjX + kObjSpace
	#const kObjSpaceY kObjY + kObjSpace
	#const kMainWX POS_X(3)	;メイン画面の大きさ
	#const kMainWY POS_Y(9)
	#const kLargeFontSize 30	;フォントサイズ
	// 座標取得モード
	#enum kGetPosAuto = 0	;オート(デスクトップのスクショから自動認識)
	#enum kGetPosClick		;クリック(クリックしたウィンドウから認識)
	#enum kGetPosCrop		;クロップ(選択した領域から認識)
	// キーボード・マウス操作
	#const kStickCtrl   64
	#const kStickEscKey 128
	#const kStickMouse  256
	#const kStickMouseR 512
	// ファイルタイプ
	#enum kFileTypeBmp = 0
	#enum kFileTypePng
	#enum kFileTypeJpeg
	// 保存方法
	#enum kSaveTypePast = 0
	#enum kSaveTypeNow
	#enum kSaveTypeFuture
	// その他
	#const global TRUE  1
	#const global FALSE 0
	#const global kRectDim 4		;「座標2つ」「オフセットと座標」における次元数
	#const global kPosDim 2			;「座標1つ」「オフセット」における次元数
	#const kMaxSaveBufferSize 49	;保存位置前後の最大フレーム数
	#const kMaxFrameRate 60			;最大フレームレート

/* 変数初期化 */
	sdim soft_log, 32000
	;座標設定
	dim window_param, kRectDim	;ウィンドウのオフセットとサイズ
	dim flash_position, kPosDim	;艦これの画面のオフセット
	get_pos_flg = FALSE
	;GUI設定
	sdim save_buffer_size_list, 1024
	repeat kMaxSaveBufferSize, 1
		save_buffer_size_list += str(cnt) + "枚\n"
	loop
	sdim frame_rate_list, 1024
	repeat kMaxFrameRate, 1
		frame_rate_list += str(cnt) + "fps\n"
	loop
	;ズレ検出用定数
	pos_x1 = kFlashWX / 2 :pos_x2 = kFlashWX + 1
	pos_y1 = kFlashWY / 2 :pos_y2 = kFlashWY + 1
	check_x.0 = pos_x1, pos_x2, pos_x2, pos_x2, pos_x1,      0,      0
	check_y.0 =      0,      0, pos_y1, pos_y2, pos_y2, pos_y2, pos_y1
	;その他初期設定
	save_buffer_size = 10						;保存する前後のフレーム数
	frame_rate = 20								;保存するfps
	save_buffer_size_index = save_buffer_size - 1
	frame_rate_index = frame_rate - 1
	file_type = kFileTypePng					;保存するファイルタイプ
	save_type = kSaveTypeNow					;保存時のモード
	sdim folder_path, 260						;フォルダパス

/* モジュール */
	#module api
		// APIを呼び出すための宣言
		#uselib "gdi32.dll"
			#func  BitBlt "BitBlt" int,int,int,int,int,int,int,int,int
			#cfunc CreateDC "CreateDCA" sptr,sptr,sptr,int
			#func  DeleteDC "DeleteDC" int
		#uselib "user32.dll"
			#cfunc GetSystemMetrics "GetSystemMetrics" int
			#cfunc GetWindowDC "GetWindowDC" int
			#func  GetWindowRect "GetWindowRect" int, int
			#func  ReleaseDC "ReleaseDC" int, int
			#cfunc WindowFromPoint "WindowFromPoint" int, int
		// APIを呼び出すための定数宣言
		#const NULL 0
		#const SRCCOPY    0x00CC0020
		#const CAPTUREBLT 0x40000000
		#const SM_XVIRTUALSCREEN  0x0000004C
		#const SM_YVIRTUALSCREEN  0x0000004D
		#const SM_CXVIRTUALSCREEN 0x0000004E
		#const SM_CYVIRTUALSCREEN 0x0000004F
		// モニタ全体のオフセットとサイズを取得する
		#deffunc GetDesktopParam array desktop_param
			desktop_param(0) = GetSystemMetrics(SM_XVIRTUALSCREEN)
			desktop_param(1) = GetSystemMetrics(SM_YVIRTUALSCREEN)
			desktop_param(2) = GetSystemMetrics(SM_CXVIRTUALSCREEN)
			desktop_param(3) = GetSystemMetrics(SM_CYVIRTUALSCREEN)
		return
		// デスクトップのスクリーンショットを取得する
		#deffunc DesktopScreenShot int desktop_buffer_id, array desktop_param
			;保存用のバッファを初期化する
			buffer desktop_buffer_id, desktop_param(2), desktop_param(3)
			;デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			;デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, desktop_param(2), desktop_param(3), hdc_screen, desktop_param(0), desktop_param(1), SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			DeleteDC hdc_screen
		return
		// 艦これの画面を探索する
		#deffunc FlashPositionSearch int desktop_buffer_id, array flash_position
			// デスクトップのスクショをCVバッファに入れる
			gsel desktop_buffer_id
			if((ginfo_sx < kFlashWX) || (ginfo_sy < kFlashWY)) :return
			cvbuffer kCVDesktopBufferID, ginfo_sx, ginfo_sy
			cvputimg kCVDesktopBufferID
			// 800x480の灰色画面の周囲に1ピクセルの白枠を付けたものをCVバッファに入れる
			gsel kFlashBufferID@
			color 100, 100, 100
			boxf 1, 1, kFlashWX, kFlashWY
			cvbuffer kCVFlashBufferID, kFlashWX, kFlashWY
			cvputimg kCVFlashBufferID
			// マッチング処理を行う
			cvmatch flash_position(0), flash_position(1), CV_TM_SQDIFF, kCVFlashBufferID, kCVDesktopBufferID
			// 「1ピクセルの白枠」の分だけ補正処理を行う
			flash_position(0) += 1
			flash_position(1) += 1
		return
		// 指定した点におけるウィンドウのハンドルを取得する
		#defcfunc GetWindowHandle array flash_point
		return WindowFromPoint(flash_point(0), flash_point(1))
		// 指定したハンドルにおけるオフセットとサイズを取得する
		#deffunc GetWindowParam int window_handle, array window_param
			dim rect, kRectDim
			GetWindowRect window_handle, varptr(rect)
			window_param(0) = rect(0)
			window_param(1) = rect(1)
			window_param(2) = rect(2) - rect(0)
			window_param(3) = rect(3) - rect(1)
		return
		// ウィンドウのスクリーンショットを取得する
		#deffunc WindowScreenShot int window_buffer_id, int window_handle, array window_param
			;保存用のバッファを初期化する
			buffer window_buffer_id, window_param(2), window_param(3)
			;ウィンドウのデバイスコンテキストを作成する
			hdc_window = GetWindowDC(window_handle)
			;ウィンドウの画像をコピーする
			BitBlt hdc, 0, 0, window_param(2), window_param(3), hdc_window, 0, 0, SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			ReleaseDC window_handle, hdc_window
		return
		// 艦これの画面のスクリーンショットを取得する
		#deffunc FlashScreenShot int flash_buffer_id, int window_handle, array flash_position
			gsel flash_buffer_id
			;デスクトップのデバイスコンテキストを作成する
			hdc_window = GetWindowDC(window_handle)
			;デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kFlashWX, kFlashWY, hdc_window, flash_position(0), flash_position(1), SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			ReleaseDC window_handle, hdc_window
		return
		#defcfunc CheckMoveFlash int window_handle, array flash_position
			gsel kCheckBufferID@
			;デスクトップのデバイスコンテキストを作成する
			hdc_window = GetWindowDC(window_handle)
			;デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kFlashWX + 2, kFlashWY + 2, hdc_window, flash_position(0) - 1, flash_position(1) - 1, SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			ReleaseDC window_handle, hdc_window
			;RGB値で判定する。四隅と各辺の中央の色を取得し、1つでも違うものがあればアウト
			pget 0, 0
			check_r = ginfo_r :check_g = ginfo_g :check_b = ginfo_b
			auto_set_flg = FALSE
			for k, 0, 7
				pget check_x@(k), check_y@(k)
				if((check_r != ginfo_r) || (check_g != ginfo_g) || (check_b != ginfo_b)){
					auto_set_flg = TRUE
					_break
				}
			next
		return auto_set_flg
	#global
	#module misc
		#const EM_SCROLL 0x00B5
		#const SB_BOTTOM 7
		// 最大値
		#defcfunc max int param_1, int param_2
			if(param_1 > param_2) :return param_1
		return param_2
		// 最小値
		#defcfunc min int param_1, int param_2
			if(param_1 < param_2) :return param_1
		return param_2
		// ログに追記
		#deffunc PutLog var soft_log, str message
			soft_log += message
			gsel kMainWindowID@
			objprm 0, soft_log
			sendmsg hMesBox@, EM_SCROLL, SB_BOTTOM, 0
		return
		// 現在時刻を取得
		#defcfunc NowTime
		return strf("%04d-%02d-%02d %02d-%02d-%02d-%03d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6), gettime(7))
		// 長方形枠を描画
		#deffunc DrawMouseSquare int mouse_x1, int mouse_y1, int mouse_x2, int mouse_y2
			square_x1 = min(mouse_x1, mouse_x2)
			square_y1 = min(mouse_y1, mouse_y2)
			square_x2 = max(mouse_x1, mouse_x2)
			square_y2 = max(mouse_y1, mouse_y2)
			color 0, 255, 255
			line square_x1, square_y1, square_x2, square_y1
			line square_x2, square_y1, square_x2, square_y2
			line square_x2, square_y2, square_x1, square_y2
			line square_x1, square_y2, square_x1, square_y1
		return
	#global

/* ウィンドウ・バッファ初期化 */
// リングバッファ
	gosub *ring_buffer_init
// 画面バッファ
	buffer kFlashBufferID, kFlashWX + 2, kFlashWY + 2
	buffer kCheckBufferID, kFlashWX + 2, kFlashWY + 2

// メイン画面
	screen kMainWindowID, kMainWX, kMainWY
	gsel kMainWindowID, 2
	title kSoftName
	// オブジェクト描画
	POS_XY 0, 4
		mesbox soft_log, SIZE_X(3), SIZE_Y(5), 4
		hMesBox = objinfo(stat, 2)
	objsize SIZE_X(1), SIZE_Y(1)
	;座標取得
		POS_XY 0, 0
			combox get_pos_mode,,"オート\nクリック\nクロップ"
		POS_XY 1, 0
			button gosub "座標取得", *get_pos
		POS_XY 2, 0
			button gosub "画像保存", *set_picture_timer
			save_picture_button_id = stat
		POS_XY 0, 1
			combox save_buffer_size_index,,save_buffer_size_list
		POS_XY 1, 1
			combox frame_rate_index,,frame_rate_list
		POS_XY 2, 1
			combox file_type,,"bmp\npng\njpeg"
		POS_XY 0, 2
			combox save_type,,"過去\n現在\n未来"
		POS_XY 0, 3
			button gosub "参照...", *browse
	objsize SIZE_X(2), SIZE_Y(1)
		POS_XY 1, 2
			chkbox "ショートカットキーを使用", shortcut_flg
		POS_XY 1, 3
			input folder_path
			folder_path_id = stat

	objenable save_picture_button_id, FALSE
	objenable folder_path_id, FALSE

/* メインループ */
	save_picture_count = -1
	shortcut_set_flg = FALSE
	save_buffer_size_index_ = save_buffer_size_index
	frame_rate_index_ = frame_rate_index
	dim window_param_, kRectDim
	repeat
		// 終了フラグ
		if(exit_flg) :end
		// 座標が取得されていたら、画像を随時更新する
		if(get_pos_flg){
			FlashScreenShot kRingBufferID + (cnt \ ring_buffer_size), window_handle, flash_position
		}
		// 保存タイマー
		if(save_picture_count == 0) :gosub *save_pictures
		if(save_picture_count > 0) :save_picture_count--
		// 設定変更を反映
		if(save_buffer_size_index_ != save_buffer_size_index){
			save_buffer_size = save_buffer_size_index + 1
			gosub *ring_buffer_init
			PutLog soft_log, "【設定変更】\n"
			PutLog soft_log, "　保存枚数：" + save_buffer_size + "\n"
			save_buffer_size_index_ = save_buffer_size_index
		}
		if(frame_rate_index_ != frame_rate_index){
			frame_rate = frame_rate_index + 1
			PutLog soft_log, "【設定変更】\n"
			PutLog soft_log, "　フレームレート：" + frame_rate + "\n"
			frame_rate_index_ = frame_rate_index
		}
		// 対象ウィンドウの状況を随時監視する
		if(get_pos_flg){
			GetWindowParam window_handle, window_param_
			if((window_param_(2) == 0) || (window_param_(3) == 0)){
				PutLog soft_log, "【ズレ検出】\n"
				PutLog soft_log, "　対象を見失いました。\n"
				get_pos_flg = FALSE
				gsel kMainWindowID
				objenable save_picture_button_id, FALSE
			}else{
				if((window_param_(2) != window_param(2)) || (window_param_(3) != window_param(3))){
					// ウィンドウサイズが変わった＝画像位置が動いた可能性がある
					window_param(0) = window_param_(0)
					window_param(1) = window_param_(1)
					window_param(2) = window_param_(2)
					window_param(3) = window_param_(3)
					gosub *get_pos_local
				}else{
					// 艦これの画面の周囲のRGB値から、ズレがないかを判定する
					if(CheckMoveFlash(window_handle, flash_position)){
						gosub *get_pos_local
					}
				}
			}
		}
		// ショートカットキー
		if(shortcut_flg){
			stick key, kStickMouseR + kStickCtrl, 0
			if(key & kStickMouseR){
				if(key & kStickCtrl){
					if(shortcut_set_flg == FALSE){
						gosub *set_picture_timer
						shortcut_set_flg = TRUE
					}
				}else{
					shortcut_set_flg = FALSE
				}
			}else{
				shortcut_set_flg = FALSE
			}
		}
		// ウェイト
		await 1000 / frame_rate
	loop

/* リングバッファを初期化 */
*ring_buffer_init
	ring_buffer_size = save_buffer_size * 2 + 1	;リングバッファに記録する枚数
	repeat ring_buffer_size
		buffer kRingBufferID + cnt, kFlashWX, kFlashWY
	loop
return

/* 艦これの画面の座標とハンドルを取得する */
*get_pos
	PutLog soft_log, "【座標取得】\n"

	// デスクトップのスクリーンショットを取得する
	dim desktop_param, kRectDim	;モニタ全体のオフセットとサイズ
	GetDesktopParam desktop_param
	DesktopScreenShot kDesktopBufferID, desktop_param
	// そこから艦これの画面を探す
	dim flash_point, kPosDim	;艦これの画面内部の座標
	switch get_pos_mode
		// オート
		case kGetPosAuto
			;艦これの画面を直接探す
			FlashPositionSearch kDesktopBufferID, flash_position
			flash_point(0) = desktop_param(0) + flash_position(0) + kFlashWX / 2
			flash_point(1) = desktop_param(1) + flash_position(1) + kFlashWY / 2
		swbreak
		// クリック
		case kGetPosClick
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面をクリックして下さい。(Escで終了)"
			mouse_click_flg = FALSE
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog soft_log, "　キャンセルされました。\n"
					break
				}
				if(key & kStickMouse){
					flash_point(0) = ginfo(0)
					flash_point(1) = ginfo(1)
					mouse_click_flg = TRUE
					break
				}
				wait 5
			loop
			gsel kSelectWindowID, -1
		swbreak
		// クロップ
		case kGetPosCrop
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面を選択して下さい。(Escで終了)"
			mouse_button_flg = FALSE
			mouse_crop_flg = FALSE
			dim rect, kRectDim
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog soft_log, "　キャンセルされました。\n"
					gsel kSelectWindowID, -1
					break
				}
				if(key & kStickMouse){
					if(mouse_button_flg){
						// 選択途中
						redraw 0
							pos 0, 0
							gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
							color
							mes "艦これの画面を選択して下さい。(Escで終了)"
							DrawMouseSquare rect(0), rect(1), mousex, mousey
						redraw 1
					}else{
						// 選択開始
						rect(0) = mousex
						rect(1) = mousey
						mouse_button_flg = TRUE
					}
				}else{
					if(mouse_button_flg){
						mouse_button_flg = FALSE
						// 選択終了
						rect(2) = mousex
						rect(3) = mousey
						;選択サイズがFlashのサイズ以上かを判定
						square_x1 = min(rect(0), rect(2))
						square_y1 = min(rect(1), rect(3))
						square_x2 = max(rect(0), rect(2))
						square_y2 = max(rect(1), rect(3))
						if((square_x2 - square_x1 >= kFlashWX) && (square_y2 - square_y1 >= kFlashWY)){
							;艦これの画面の位置を探し、その中央の位置を返す
							;(つまり、オートモードでの探索範囲を制限したVerってこと)
							dim screen_param, kRectDim
							screen_param(0) = square_x1 + desktop_param(0)
							screen_param(1) = square_y1 + desktop_param(1)
							screen_param(2) = square_x2 - square_x1
							screen_param(3) = square_y2 - square_y1
							gsel kSelectWindowID, -1
							DesktopScreenShot kDesktopBufferID, screen_param
							FlashPositionSearch kDesktopBufferID, flash_position
							flash_point(0) = screen_param(0) + flash_position(0) + kFlashWX / 2
							flash_point(1) = screen_param(1) + flash_position(1) + kFlashWY / 2
							mouse_crop_flg = TRUE
							break
						}
					}
				}
				wait 5
			loop
			
		swbreak
	swend
	if((get_pos_mode == kGetPosClick) && (mouse_click_flg == FALSE)) :return
	if((get_pos_mode == kGetPosCrop) && (mouse_crop_flg == FALSE)) :return
	// 艦これの画面のハンドルを取得する
	window_handle = GetWindowHandle(flash_point)
	// 艦これの画面の座標を取得する
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	FlashPositionSearch kDesktopBufferID, flash_position
	get_pos_flg = TRUE
	gsel kMainWindowID
	objenable save_picture_button_id, TRUE

	PutLog soft_log, "　ウィンドウハンドル：" + window_handle + "\n"
	PutLog soft_log, "　ウィンドウ左上座標：" + window_param(0) + "," + window_param(1) + "\n"
	PutLog soft_log, "　ウィンドウサイズ：" + window_param(2) + "," + window_param(3) + "\n"
	PutLog soft_log, "　艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1) + "\n"
return

/* 艦これの座標を取得し直す */
*get_pos_local
	PutLog soft_log, "【ズレ検出】\n"
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	FlashPositionSearch kDesktopBufferID, flash_position
	PutLog soft_log, "　艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1) + "\n"
return

/* リングバッファに保存するためのタイマーを仕掛ける */
*set_picture_timer
	if(get_pos_flg == FALSE) :return
	switch save_type
		case kSaveTypePast
			save_picture_count = 0
		swbreak
		case kSaveTypeNow
			save_picture_count = save_buffer_size
		swbreak
		case kSaveTypeFuture
			save_picture_count = save_buffer_size * 2
		swbreak
	swend
return

/* リングバッファの画像を保存する */
*save_pictures
	if(get_pos_flg == FALSE) :return
	PutLog soft_log, "【画像保存】\n"
	PutLog soft_log, "　画像保存中……\n"
	filename = NowTime()
	if(folder_path != ""){
		filename = folder_path + "\\" + filename
	}
	switch file_type
		case kFileTypeBmp
			for k, 0, ring_buffer_size
				gsel kRingBufferID + (k + cnt + 1) \ ring_buffer_size
				bmpsave filename + "_" + strf("%02d", k + 1) + ".bmp"
			next
		swbreak
		case kFileTypePng
			cvbuffer kCVFlashBufferID, kFlashWX, kFlashWY
			for k, 0, ring_buffer_size
				gsel kRingBufferID + (k + cnt + 1) \ ring_buffer_size
				cvputimg kCVFlashBufferID
				cvsave filename + "_" + strf("%02d", k + 1) + ".png", kCVFlashBufferID
			next
		swbreak
		case kFileTypeJpeg
			cvbuffer kCVFlashBufferID, kFlashWX, kFlashWY
			for k, 0, ring_buffer_size
				gsel kRingBufferID + (k + cnt + 1) \ ring_buffer_size
				cvputimg kCVFlashBufferID
				cvsave filename + "_" + strf("%02d", k + 1) + ".jpg", kCVFlashBufferID
			next
		swbreak
	swend
	PutLog soft_log, "　画像保存完了\n"
	save_picture_count = -1
return

/* フォルダ参照 */
*browse
	selfolder folder_path,"保存先フォルダ"
	gsel kMainWindowID
	objprm folder_path_id, folder_path
return

/* 終了時の処理(Windows 8以降用対策) */
*exit
	exit_flg = TRUE
return
