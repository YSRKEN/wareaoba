/* 戦場のカメラマン 青葉 Ver.1.3 */

	#packopt name "wareaoba"
	#include "hspcv.as"
	#include "hspext.as"
	onexit gosub *exit

/* マクロ宣言 */
	#define kSoftName "戦場のカメラマン 青葉"
	#define ctype POS_X(%1) (%1) * kObjSpaceX + kObjSpace
	#define ctype POS_Y(%1) (%1) * kObjSpaceY + kObjSpace
	#define POS_XY(%1, %2) pos POS_X(%1), POS_Y(%2)
	#define ctype SIZE_X(%1) (%1) * kObjSpaceX - kObjSpace
	#define ctype SIZE_Y(%1) (%1) * kObjSpaceY - kObjSpace

/* 定数宣言 */
	// 画面ID
	#enum kMainWindowID = 0	;メイン画面のID
	#enum kSelectWindowID	;選択画面のID
	#enum kDesktopBufferID	;デスクトップのスクショを保存するためのID
	#enum kFlashBufferID	;艦これの画面を保存するためのID
	#enum kCheckBufferID	;ズレ検出用のID
	#enum kOptionWindowID	;選択画面のID
	#enum kRingBufferID		;リングバッファの最初のID
	// CV画面ID
	#enum global kCVDesktopBufferID = 0
	#enum global kCVFlashBufferID
	// オブジェクト
	#const global kFlashWX 800
	#const global kFlashWY 480
	#const kObjX 60			;ボタン等のオブジェクトの大きさ
	#const kObjY 20
	#const kObjSpace 10		;オブジェクトの間隔
	#const kObjSpaceX kObjX + kObjSpace
	#const kObjSpaceY kObjY + kObjSpace
	#const kMainWX POS_X(3)	;メイン画面の大きさ
	#const kMainWY POS_Y(10)
	#const kLargeFontSize 30	;フォントサイズ
	// 座標取得モード
	#enum kGetPosAuto = 0	;オート(デスクトップのスクショから自動認識)
	#enum kGetPosClick		;クリック(クリックしたウィンドウから認識)
	#enum kGetPosCrop		;クロップ(選択した領域から認識)
	// キーボード・マウス操作
	#const kStickCtrl   64
	#const kStickEscKey 128
	#const kStickMouse  256
	#const kStickMouseR 512
	// ファイルタイプ
	#enum kFileTypeBmp = 0
	#enum kFileTypePng
	#enum kFileTypeJpeg
	// 保存方法
	#enum kSaveTypePast = 0
	#enum kSaveTypeNow
	#enum kSaveTypeFuture
	// その他
	#const global TRUE  1
	#const global FALSE 0
	#const global kRectDim 4		;「座標2つ」「オフセットと座標」における次元数
	#const global kPosDim 2			;「座標1つ」「オフセット」における次元数
	#const kMaxSaveBufferSize 49	;保存位置前後の最大フレーム数
	#const kMaxFrameRate 60			;最大フレームレート

/* 変数初期化 */
	sdim soft_log, 32000
	;座標設定
	dim window_param, kRectDim	;ウィンドウのオフセットとサイズ
	dim flash_position, kPosDim	;艦これの画面のオフセット
	get_pos_flg = FALSE
	;GUI設定
	sdim save_buffer_size_list, 1024
	repeat kMaxSaveBufferSize, 1
		save_buffer_size_list += str(cnt) + "枚\n"
	loop
	sdim frame_rate_list, 1024
	repeat kMaxFrameRate, 1
		frame_rate_list += str(cnt) + "fps\n"
	loop
	;ズレ検出用定数
	;左上・右上・右下・左下・上・右・下・左
	pos_x1 = kFlashWX / 2 :pos_x2 = kFlashWX + 1
	pos_y1 = kFlashWY / 2 :pos_y2 = kFlashWY + 1
	check_x.0 = 0, pos_x2, pos_x2,      0, pos_x1, pos_x2, pos_x1,      0
	check_y.0 = 0,      0, pos_y2, pos_y2,      0, pos_y1, pos_y2, pos_y1
	move_x.0 = 1, -1, -1,  1,  0, -1,  0,  1
	move_y.0 = 1,  1, -1, -1,  1,  0, -1,  0
	;その他初期設定
	save_buffer_size = 10						;保存する前後のフレーム数
	frame_rate = 5								;保存するfps
	save_buffer_size_index = save_buffer_size - 1
	frame_rate_index = frame_rate - 1
	file_type = kFileTypePng					;保存するファイルタイプ
	save_type = kSaveTypeNow					;保存時のモード
	sdim folder_path, 260						;フォルダパス
	auto_cap_antiair_cutin_flg = TRUE
	auto_cap_day_cutin_flg     = TRUE
	auto_cap_day_attack_flg    = TRUE
	auto_cap_night_cutin_flg   = TRUE
	auto_cap_night_attack_flg  = TRUE
	auto_cap_broken_flg        = TRUE

/* モジュール */
	#module api
		// APIを呼び出すための宣言
		#uselib "gdi32.dll"
			#func  BitBlt "BitBlt" int,int,int,int,int,int,int,int,int
			#cfunc CreateDC "CreateDCA" sptr,sptr,sptr,int
			#func  DeleteDC "DeleteDC" int
		#uselib "user32.dll"
			#cfunc GetSystemMetrics "GetSystemMetrics" int
			#cfunc GetWindowDC "GetWindowDC" int
			#func  GetWindowRect "GetWindowRect" int, int
			#func  ReleaseDC "ReleaseDC" int, int
			#cfunc WindowFromPoint "WindowFromPoint" int, int
		// APIを呼び出すための定数宣言
		#const NULL 0
		#const SRCCOPY    0x00CC0020
		#const CAPTUREBLT 0x40000000
		#const SM_XVIRTUALSCREEN  0x0000004C
		#const SM_YVIRTUALSCREEN  0x0000004D
		#const SM_CXVIRTUALSCREEN 0x0000004E
		#const SM_CYVIRTUALSCREEN 0x0000004F
		// モニタ全体のオフセットとサイズを取得する
		#deffunc GetDesktopParam array desktop_param
			desktop_param(0) = GetSystemMetrics(SM_XVIRTUALSCREEN)
			desktop_param(1) = GetSystemMetrics(SM_YVIRTUALSCREEN)
			desktop_param(2) = GetSystemMetrics(SM_CXVIRTUALSCREEN)
			desktop_param(3) = GetSystemMetrics(SM_CYVIRTUALSCREEN)
		return
		// デスクトップのスクリーンショットを取得する
		#deffunc DesktopScreenShot int desktop_buffer_id, array desktop_param
			;保存用のバッファを初期化する
			buffer desktop_buffer_id, desktop_param(2), desktop_param(3)
			;デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			;デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, desktop_param(2), desktop_param(3), hdc_screen, desktop_param(0), desktop_param(1), SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			DeleteDC hdc_screen
		return
		// 艦これの画面を探索する
		#deffunc FlashPositionSearch int desktop_buffer_id, array flash_position
			// デスクトップのスクショをCVバッファに入れる
			gsel desktop_buffer_id
			if((ginfo_sx < kFlashWX) || (ginfo_sy < kFlashWY)) :return
			cvbuffer kCVDesktopBufferID, ginfo_sx, ginfo_sy
			cvputimg kCVDesktopBufferID
			// 800x480の灰色画面の周囲に1ピクセルの白枠を付けたものをCVバッファに入れる
			gsel kFlashBufferID@
			color 100, 100, 100
			boxf 1, 1, kFlashWX, kFlashWY
			cvbuffer kCVFlashBufferID, kFlashWX, kFlashWY
			cvputimg kCVFlashBufferID
			// マッチング処理を行う
			cvmatch flash_position(0), flash_position(1), CV_TM_SQDIFF, kCVFlashBufferID, kCVDesktopBufferID
			// 「1ピクセルの白枠」の分だけ補正処理を行う
			flash_position(0) += 1
			flash_position(1) += 1
		return
		// 指定した点におけるウィンドウのハンドルを取得する
		#defcfunc GetWindowHandle array flash_point
		return WindowFromPoint(flash_point(0), flash_point(1))
		// 指定したハンドルにおけるオフセットとサイズを取得する
		#deffunc GetWindowParam int window_handle, array window_param
			dim rect, kRectDim
			GetWindowRect window_handle, varptr(rect)
			window_param(0) = rect(0)
			window_param(1) = rect(1)
			window_param(2) = rect(2) - rect(0)
			window_param(3) = rect(3) - rect(1)
		return
		// ウィンドウのスクリーンショットを取得する
		#deffunc WindowScreenShot int window_buffer_id, int window_handle, array window_param
			;保存用のバッファを初期化する
			buffer window_buffer_id, window_param(2), window_param(3)
			;ウィンドウのデバイスコンテキストを作成する
			hdc_window = GetWindowDC(window_handle)
			;ウィンドウの画像をコピーする
			BitBlt hdc, 0, 0, window_param(2), window_param(3), hdc_window, 0, 0, SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			ReleaseDC window_handle, hdc_window
		return
		// 艦これの画面のスクリーンショットを取得する
		#deffunc FlashScreenShot int flash_buffer_id, int window_handle, array flash_position
			gsel flash_buffer_id
			;デスクトップのデバイスコンテキストを作成する
			hdc_window = GetWindowDC(window_handle)
			;デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kFlashWX, kFlashWY, hdc_window, flash_position(0), flash_position(1), SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			ReleaseDC window_handle, hdc_window
		return
		#defcfunc CheckMoveFlash int window_handle, array flash_position
			gsel kCheckBufferID@
			;デスクトップのデバイスコンテキストを作成する
			hdc_window = GetWindowDC(window_handle)
			;デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kFlashWX + 2, kFlashWY + 2, hdc_window, flash_position(0) - 1, flash_position(1) - 1, SRCCOPY | CAPTUREBLT
			;デバイスコンテキストを削除する
			ReleaseDC window_handle, hdc_window
			;RGB値で判定する。四隅と各辺の中央の色を取得し、1つでも違うものがあればアウト
			dim clr, 8
			for k, 0, 8
				pget check_x@(k), check_y@(k)
				clr(k) = (ginfo_r * 1000 + ginfo_g) * 1000 + ginfo_b
			next
			auto_set_flg = FALSE
			if((clr(0) != clr(1)) && (clr(1) == clr(2))){
				flash_position(0) += move_x@(0)
				flash_position(1) += move_y@(0)
				auto_set_flg = TRUE
			}else{
				for k, 1, 8
					if(clr(0) != clr(k)){
						flash_position(0) += move_x@(k)
						flash_position(1) += move_y@(k)
						auto_set_flg = TRUE
						_break
					}
				next
			}
		return auto_set_flg
	#global
	#module misc
		#const EM_SCROLL 0x00B5
		#const SB_BOTTOM 7
		// 最大値
		#defcfunc max int param_1, int param_2
			if(param_1 > param_2) :return param_1
		return param_2
		// 最小値
		#defcfunc min int param_1, int param_2
			if(param_1 < param_2) :return param_1
		return param_2
		// ログに追記
		#deffunc PutLog str message
			soft_log@ += message + "\n"
			gsel kMainWindowID@
			objprm 0, soft_log@
			sendmsg hMesBox@, EM_SCROLL, SB_BOTTOM, 0
		return
		// 現在時刻を取得
		#defcfunc NowTime
		return strf("%04d-%02d-%02d %02d-%02d-%02d-%03d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6), gettime(7))
		// 長方形枠を描画
		#deffunc DrawMouseSquare int mouse_x1, int mouse_y1, int mouse_x2, int mouse_y2
			square_x1 = min(mouse_x1, mouse_x2)
			square_y1 = min(mouse_y1, mouse_y2)
			square_x2 = max(mouse_x1, mouse_x2)
			square_y2 = max(mouse_y1, mouse_y2)
			color 0, 255, 255
			line square_x1, square_y1, square_x2, square_y1
			line square_x2, square_y1, square_x2, square_y2
			line square_x2, square_y2, square_x1, square_y2
			line square_x1, square_y2, square_x1, square_y1
		return
		// 色判定
		#defcfunc NearColor int px_, int py_, int clr_r_, int clr_g_, int clr_b_
			pget px_, py_
			diff_r = ginfo_r - clr_r_
			diff_g = ginfo_g - clr_g_
			diff_b = ginfo_b - clr_b_
			diff = diff_r * diff_r + diff_g * diff_g + diff_b * diff_b
			if(diff < 100) :return TRUE
		return FALSE
		// 撮影タイミングを指定秒だけ後にズラす
		#defcfunc WaitTime double time
		return int(time * frame_rate@ + 0.5)
	#global

/* ウィンドウ・バッファ初期化 */
// リングバッファ
	gosub *ring_buffer_init
// 画面バッファ
	buffer kFlashBufferID, kFlashWX + 2, kFlashWY + 2
	buffer kCheckBufferID, kFlashWX + 2, kFlashWY + 2

// オプション画面
	screen kOptionWindowID, POS_X(2), POS_Y(6)
	title "オプション"
	objsize SIZE_X(2), SIZE_Y(1)
		POS_XY 0, 0
			chkbox "対空カットイン", auto_cap_antiair_cutin_flg
		POS_XY 0, 1
			chkbox "昼戦カットイン", auto_cap_day_cutin_flg
		POS_XY 0, 2
			chkbox "昼戦連撃・昼戦砲撃", auto_cap_day_attack_flg
		POS_XY 0, 3
			chkbox "夜戦カットイン", auto_cap_night_cutin_flg
		POS_XY 0, 4
			chkbox "夜戦連撃・夜戦砲撃", auto_cap_night_attack_flg
		POS_XY 0, 5
			chkbox "中破・大破時", auto_cap_broken_flg
	gsel kOptionWindowID, -1

// メイン画面
	screen kMainWindowID, kMainWX, kMainWY
	gsel kMainWindowID, 2
	title kSoftName
	// オブジェクト描画
	POS_XY 0, 5
		mesbox soft_log, SIZE_X(3), SIZE_Y(5), 4
		hMesBox = objinfo(stat, 2)
	objsize SIZE_X(1), SIZE_Y(1)
		POS_XY 0, 0
			combox get_pos_mode,,"オート\nクリック\nクロップ"
		POS_XY 1, 0
			button gosub "座標取得", *get_pos
		POS_XY 2, 0
			button gosub "画像保存", *set_picture_timer
			save_picture_button_id = stat
		POS_XY 0, 1
			combox save_buffer_size_index,,save_buffer_size_list
		POS_XY 1, 1
			combox frame_rate_index,,frame_rate_list
		POS_XY 2, 1
			combox file_type,,"bmp\npng\njpeg"
		POS_XY 0, 2
			combox save_type,,"過去\n現在\n未来"
		POS_XY 0, 3
			button gosub "参照...", *browse
		POS_XY 0, 4
			button gosub "選択...", *option
	objsize SIZE_X(2), SIZE_Y(1)
		POS_XY 1, 2
			chkbox "ショートカットキーを使用", shortcut_flg
		POS_XY 1, 3
			input folder_path
			folder_path_id = stat
		POS_XY 1, 4
			chkbox "特定シーン自動撮影", auto_cap_flg

	objenable save_picture_button_id, FALSE
	objenable folder_path_id, FALSE

/* メインループ */
	save_picture_count = -1
	shortcut_set_flg = FALSE
	save_buffer_size_index_ = save_buffer_size_index
	frame_rate_index_ = frame_rate_index
	auto_cap_flg_ = auto_cap_flg
	dim window_param_, kRectDim
	repeat
		// 終了フラグ
		if(exit_flg) :end
		// 座標が取得されていたら、画像を随時更新する
		if(get_pos_flg){
			FlashScreenShot kRingBufferID + (cnt \ ring_buffer_size), window_handle, flash_position
		}
		// 保存タイマー
		if(save_picture_count == 0) :gosub *save_pictures
		if(save_picture_count > 0) :save_picture_count--
		// 設定変更を反映
		if(save_buffer_size_index_ != save_buffer_size_index){
			save_buffer_size = save_buffer_size_index + 1
			gosub *ring_buffer_init
			PutLog "【設定変更】"
			PutLog "　保存枚数：" + save_buffer_size
			save_buffer_size_index_ = save_buffer_size_index
		}
		if(frame_rate_index_ != frame_rate_index){
			frame_rate = frame_rate_index + 1
			PutLog "【設定変更】"
			PutLog "　フレームレート：" + frame_rate
			frame_rate_index_ = frame_rate_index
		}
		if(auto_cap_flg_ != auto_cap_flg){
			PutLog "【設定変更】"
			if(auto_cap_flg){
				PutLog "　自動撮影：ON"
			}else{
				PutLog "　自動撮影：OFF"
			}
			auto_cap_flg_ = auto_cap_flg
			auto_cap_stop_flg = FALSE
		}
		// 対象ウィンドウの状況を随時監視する
		if(get_pos_flg){
			// ズレ検出・ズレ補正
			GetWindowParam window_handle, window_param_
			if((window_param_(2) == 0) || (window_param_(3) == 0)){
				PutLog "【ズレ検出】"
				PutLog "　対象を見失いました。"
				get_pos_flg = FALSE
				gsel kMainWindowID
				objenable save_picture_button_id, FALSE
			}else{
				if((window_param_(2) != window_param(2)) || (window_param_(3) != window_param(3))){
					// ウィンドウサイズが変わった＝画像位置が動いた可能性がある
					window_param(0) = window_param_(0)
					window_param(1) = window_param_(1)
					window_param(2) = window_param_(2)
					window_param(3) = window_param_(3)
					gosub *get_pos_local
				}else{
					// 艦これの画面の周囲のRGB値から、ズレがないかを判定する
					if(CheckMoveFlash(window_handle, flash_position)){
						gosub *get_pos_local
					}
				}
			}
			// 自動撮影
			if((auto_cap_flg) && (auto_cap_stop_flg == FALSE)){
				gsel kRingBufferID + (cnt \ ring_buffer_size)
				if(auto_cap_antiair_cutin_flg){
					if(NearColor(785,11,163,198,221)){
					if(NearColor(7,13,172,204,224)){
					if(NearColor(787,473,137,183,206)){
						PutLog "【自動撮影(対空カットイン)】"
						gosub *set_picture_timer
						save_picture_count += WaitTime(1.0)
						auto_cap_stop_flg = TRUE
					}
					}
					}
				}
				if(auto_cap_day_cutin_flg){
					if(NearColor(24,40,103,195,217)){
					if(NearColor(31,41,102,201,222)){
					if(NearColor(48,43,102,201,222)){
						PutLog "【自動撮影(昼戦カットイン)】"
						gosub *set_picture_timer
						save_picture_count += WaitTime(1.6)
						auto_cap_stop_flg = TRUE
					}
					}
					}
				}
				if(auto_cap_day_attack_flg){
					if(NearColor(24,41,29,179,183)){
					if(NearColor(27,465,246,241,233)){
					if(NearColor(262,461,234,225,215)){
					/* 敵の場合は下2行を次のように書き換える
					if(NearColor(473,464,248,243,235)){
					if(NearColor(708,462,228,219,209)){*/
						PutLog "【自動撮影(昼戦連撃・昼戦砲撃)】"
						gosub *set_picture_timer
						auto_cap_stop_flg = TRUE
					}
					}
					}
				}
				if(auto_cap_night_cutin_flg){
					if(NearColor(25,41,18,20,22)){
					if(NearColor(20,41,3,3,9)){
					if(NearColor(49,35,18,20,22)){
						PutLog "【自動撮影(夜戦カットイン)】"
						gosub *set_picture_timer
						save_picture_count += WaitTime(1.0)
						auto_cap_stop_flg = TRUE
					}
					}
					}
				}
				if(auto_cap_night_attack_flg){
					if(NearColor(25,41,219,238,254)){
					if(NearColor(27,465,246,241,233)){
					if(NearColor(262,461,234,225,215)){
					/* 敵の場合は下2行を次のように書き換える
					if(NearColor(473,464,248,243,235)){
					if(NearColor(708,462,228,219,209)){*/
						PutLog "【自動撮影(夜戦連撃・夜戦砲撃)】"
						gosub *set_picture_timer
						auto_cap_stop_flg = TRUE
					}
					}
					}
				}
				if(auto_cap_broken_flg){
					// 中破・大破時
					// この場合では、本来WaitTimeでズラさなくても
					// 正確なタイミングで撮れるが、被弾〜中破絵までの
					// 一連が10枚・5fpsで綺麗に収まるようにズラした
					// (このズラしは現在モードにのみ反映される)
					if(NearColor(0,0,250,250,250)){
					if(NearColor(700,316,230,180,114)){
					if(NearColor(760,447,238,180,116)){
						PutLog "【自動撮影(中破時)】"
						gosub *set_picture_timer
						if(save_type == kSaveTypeNow){
							save_picture_count += WaitTime(0.8)
						}
						auto_cap_stop_flg = TRUE
					}
					}
					}
					if(NearColor(0,0,250,250,250)){
					if(NearColor(705,326,255,101,93)){
					if(NearColor(766,472,147,82,79)){
						PutLog "【自動撮影(大破時)】"
						gosub *set_picture_timer
						if(save_type == kSaveTypeNow){
							save_picture_count += WaitTime(0.8)
						}
						auto_cap_stop_flg = TRUE
					}
					}
					}
				}
			}
		}
		// ショートカットキー
		if(shortcut_flg){
			stick key, kStickMouseR + kStickCtrl, 0
			if(key & kStickMouseR){
				if(key & kStickCtrl){
					if(shortcut_set_flg == FALSE){
						gosub *set_picture_timer
						shortcut_set_flg = TRUE
					}
				}else{
					shortcut_set_flg = FALSE
				}
			}else{
				shortcut_set_flg = FALSE
			}
		}
		// ウェイト
		await 1000 / frame_rate
	loop

/* リングバッファを初期化 */
*ring_buffer_init
	ring_buffer_size = save_buffer_size * 2 + 1	;リングバッファに記録する枚数
	repeat ring_buffer_size
		buffer kRingBufferID + cnt, kFlashWX, kFlashWY
	loop
return

/* 艦これの画面の座標とハンドルを取得する */
*get_pos
	PutLog "【座標取得】"

	// デスクトップのスクリーンショットを取得する
	dim desktop_param, kRectDim	;モニタ全体のオフセットとサイズ
	GetDesktopParam desktop_param
	DesktopScreenShot kDesktopBufferID, desktop_param
	// そこから艦これの画面を探す
	dim flash_point, kPosDim	;艦これの画面内部の座標
	switch get_pos_mode
		// オート
		case kGetPosAuto
			;艦これの画面を直接探す
			FlashPositionSearch kDesktopBufferID, flash_position
			flash_point(0) = desktop_param(0) + flash_position(0) + kFlashWX / 2
			flash_point(1) = desktop_param(1) + flash_position(1) + kFlashWY / 2
		swbreak
		// クリック
		case kGetPosClick
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面をクリックして下さい。(Escで終了)"
			mouse_click_flg = FALSE
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "　キャンセルされました。"
					break
				}
				if(key & kStickMouse){
					flash_point(0) = ginfo(0)
					flash_point(1) = ginfo(1)
					mouse_click_flg = TRUE
					break
				}
				wait 5
			loop
			gsel kSelectWindowID, -1
		swbreak
		// クロップ
		case kGetPosCrop
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面を選択して下さい。(Escで終了)"
			mouse_button_flg = FALSE
			mouse_crop_flg = FALSE
			dim rect, kRectDim
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "　キャンセルされました。"
					gsel kSelectWindowID, -1
					break
				}
				if(key & kStickMouse){
					if(mouse_button_flg){
						// 選択途中
						redraw 0
							pos 0, 0
							gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
							color
							mes "艦これの画面を選択して下さい。(Escで終了)"
							DrawMouseSquare rect(0), rect(1), mousex, mousey
						redraw 1
					}else{
						// 選択開始
						rect(0) = mousex
						rect(1) = mousey
						mouse_button_flg = TRUE
					}
				}else{
					if(mouse_button_flg){
						mouse_button_flg = FALSE
						// 選択終了
						rect(2) = mousex
						rect(3) = mousey
						;選択サイズがFlashのサイズ以上かを判定
						square_x1 = min(rect(0), rect(2))
						square_y1 = min(rect(1), rect(3))
						square_x2 = max(rect(0), rect(2))
						square_y2 = max(rect(1), rect(3))
						if((square_x2 - square_x1 >= kFlashWX) && (square_y2 - square_y1 >= kFlashWY)){
							;艦これの画面の位置を探し、その中央の位置を返す
							;(つまり、オートモードでの探索範囲を制限したVerってこと)
							dim screen_param, kRectDim
							screen_param(0) = square_x1 + desktop_param(0)
							screen_param(1) = square_y1 + desktop_param(1)
							screen_param(2) = square_x2 - square_x1
							screen_param(3) = square_y2 - square_y1
							gsel kSelectWindowID, -1
							DesktopScreenShot kDesktopBufferID, screen_param
							FlashPositionSearch kDesktopBufferID, flash_position
							flash_point(0) = screen_param(0) + flash_position(0) + kFlashWX / 2
							flash_point(1) = screen_param(1) + flash_position(1) + kFlashWY / 2
							mouse_crop_flg = TRUE
							break
						}
					}
				}
				wait 5
			loop
			
		swbreak
	swend
	if((get_pos_mode == kGetPosClick) && (mouse_click_flg == FALSE)) :return
	if((get_pos_mode == kGetPosCrop) && (mouse_crop_flg == FALSE)) :return
	// 艦これの画面のハンドルを取得する
	window_handle = GetWindowHandle(flash_point)
	// 艦これの画面の座標を取得する
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	FlashPositionSearch kDesktopBufferID, flash_position
	get_pos_flg = TRUE
	gsel kMainWindowID
	objenable save_picture_button_id, TRUE

	PutLog "　ウィンドウハンドル：" + window_handle
	PutLog "　ウィンドウ左上座標：" + window_param(0) + "," + window_param(1)
	PutLog "　ウィンドウサイズ：" + window_param(2) + "," + window_param(3)
	PutLog "　艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1)
return

/* 艦これの座標を取得し直す */
*get_pos_local
	PutLog "【ズレ検出】"
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	FlashPositionSearch kDesktopBufferID, flash_position
	PutLog "　艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1)
return

/* リングバッファに保存するためのタイマーを仕掛ける */
*set_picture_timer
	if(get_pos_flg == FALSE) :return
	switch save_type
		case kSaveTypePast
			save_picture_count = 0
		swbreak
		case kSaveTypeNow
			save_picture_count = save_buffer_size
		swbreak
		case kSaveTypeFuture
			save_picture_count = save_buffer_size * 2
		swbreak
	swend
return

/* リングバッファの画像を保存する */
*save_pictures
	if(get_pos_flg == FALSE) :return
	PutLog "【画像保存】"
	PutLog "　画像保存中……"
	filename = NowTime()
	if(folder_path != ""){
		filename = folder_path + "\\" + filename
	}
	switch file_type
		case kFileTypeBmp
			for k, 0, ring_buffer_size
				gsel kRingBufferID + (k + cnt + 1) \ ring_buffer_size
				bmpsave filename + "_" + strf("%02d", k + 1) + ".bmp"
			next
		swbreak
		case kFileTypePng
			cvbuffer kCVFlashBufferID, kFlashWX, kFlashWY
			for k, 0, ring_buffer_size
				gsel kRingBufferID + (k + cnt + 1) \ ring_buffer_size
				cvputimg kCVFlashBufferID
				cvsave filename + "_" + strf("%02d", k + 1) + ".png", kCVFlashBufferID
			next
		swbreak
		case kFileTypeJpeg
			cvbuffer kCVFlashBufferID, kFlashWX, kFlashWY
			for k, 0, ring_buffer_size
				gsel kRingBufferID + (k + cnt + 1) \ ring_buffer_size
				cvputimg kCVFlashBufferID
				cvsave filename + "_" + strf("%02d", k + 1) + ".jpg", kCVFlashBufferID
			next
		swbreak
	swend
	PutLog "　画像保存完了"
	save_picture_count = -1
	auto_cap_stop_flg = FALSE
return

/* フォルダ参照 */
*browse
	selfolder folder_path,"保存先フォルダ"
	gsel kMainWindowID
	objprm folder_path_id, folder_path
return

/* 設定画面表示 */
*option
	gsel kOptionWindowID, 2
return

/* 終了時の処理(Windows 8以降用対策) */
*exit
	if(wparam != kMainWindowID){
			gsel wparam, -1
	}else{
		exit_flg = TRUE
	}
return
